/*
 * Copyright : (C) 2023 Phytium Information Technology, Inc.
 * All Rights Reserved.
 *
 * This program is OPEN SOURCE software: you can redistribute it and/or modify it
 * under the terms of the Phytium Public License as published by the Phytium Technology Co.,Ltd,
 * either version 1.0 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the Phytium Public License for more details.
 *
 *
 * FilePath: pin_gpio_intr_example.c
 * Date: 2022-03-01 12:54:42
 * LastEditTime: 2022-03-05 17:28:07
 * Description:  This file is for pin gpio interrupt tigger example function implmentation.
 *
 * Modify History:
 *  Ver      Who        Date         Changes
 * -----   -------    --------     --------------------------------------
 *  1.0  liqiaozhong  2023/03/05   first commit
 *  1.1  liqiaozhong  2023/8/11    adapt to new iomux
 */


/***************************** Include Files *********************************/
#include "sdkconfig.h"
#ifndef SDK_CONFIG_H__
    #warning "Please include sdkconfig.h"
#endif

#include <string.h>
#include <stdio.h>
#include "strto.h"

#include "ftypes.h"
#include "fdebug.h"
#include "fassert.h"
#include "fsleep.h"
#include "finterrupt.h"
#include "fcpu_info.h"
#include "fio_mux.h"

#include "fgpio.h"

#include "pin_common.h"
#include "pin_gpio_intr_example.h"
/************************** Constant Definitions *****************************/
#if defined(CONFIG_FIREFLY_DEMO_BOARD)
static const u32 ctrl_id = FGPIO3_ID;
static const FGpioPinId input_pin_index = {FGPIO3_ID, FGPIO_PORT_A, FGPIO_PIN_1};
static const FGpioPinId output_pin_index = {FGPIO3_ID, FGPIO_PORT_A, FGPIO_PIN_2};
#elif defined(CONFIG_E2000Q_DEMO_BOARD) || defined(CONFIG_E2000D_DEMO_BOARD)
static const u32 ctrl_id = FGPIO4_ID;
static const FGpioPinId input_pin_index = {FGPIO4_ID, FGPIO_PORT_A, FGPIO_PIN_11};
static const FGpioPinId output_pin_index = {FGPIO4_ID, FGPIO_PORT_A, FGPIO_PIN_12};
#elif defined(CONFIG_PD2308_DEMO_BOARD)
static const u32 ctrl_id = FGPIO0_ID;
static const FGpioPinId input_pin_index = {FGPIO0_ID, FGPIO_PORT_A, FGPIO_PIN_8};
static const FGpioPinId output_pin_index = {FGPIO0_ID, FGPIO_PORT_A, FGPIO_PIN_10};
#endif

static FGpioIrqType irq_type = FGPIO_IRQ_TYPE_LEVEL_HIGH;
static const char *irq_type_names[] = 
{
    [FGPIO_IRQ_TYPE_EDGE_FALLING] = "falling edge",
    [FGPIO_IRQ_TYPE_EDGE_RISING] = "rising edge",
    [FGPIO_IRQ_TYPE_LEVEL_LOW] = "level low",
    [FGPIO_IRQ_TYPE_LEVEL_HIGH] = "level high"
};
/**************************** Type Definitions *******************************/
static int intr_flag = 0;
/************************** Variable Definitions *****************************/
static FGpio ctrl_instance; 
static FGpioPin input_pin_instance;
static FGpioPin output_pin_instance;
/***************** Macros (Inline Functions) Definitions *********************/

/************************** Function Prototypes ******************************/

/************************** Function *****************************************/
static void FPinAckIrq(s32 vector, void *param)
{
    printf("Assert %s for gpio %d-%c-%d !!!\n", 
          irq_type_names[irq_type], 
          input_pin_index.ctrl,
          (input_pin_index.port == FGPIO_PORT_A)?'a':'b',
          input_pin_index.pin);

    intr_flag = 1;

    /* for level-triggered interrupt, reset out-pin level so that interrupt 
       occurr once only */
    if ((FGPIO_IRQ_TYPE_EDGE_FALLING == irq_type) || (FGPIO_IRQ_TYPE_LEVEL_LOW == irq_type))
    {
        FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_HIGH);
    }
    else if ((FGPIO_IRQ_TYPE_EDGE_RISING == irq_type) || (FGPIO_IRQ_TYPE_LEVEL_HIGH == irq_type))
    {
        FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_LOW);
    }
}

static void FPinTriggerFallingEdgeIrq(void)
{
    intr_flag = 0;
    FGpioSetInterruptType(&input_pin_instance, FGPIO_IRQ_TYPE_EDGE_FALLING);
    FGpioSetInterruptMask(&input_pin_instance, TRUE);

    FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_LOW); /* init output pin with low level*/
    fsleep_millisec(100);

    /* falling edge */
    FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_HIGH);
    fsleep_millisec(100);
    FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_LOW);
}

static void FPinTriggerRisingEdgeIrq(void)
{
    intr_flag = 0;
    FGpioSetInterruptType(&input_pin_instance, FGPIO_IRQ_TYPE_EDGE_RISING);
    FGpioSetInterruptMask(&input_pin_instance, TRUE);

    FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_LOW); /* init output pin with low level*/
    fsleep_millisec(100);

    /* rising edge */
    FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_LOW);
    fsleep_millisec(100);
    FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_HIGH);
}

static void FPinTriggerLevelLowIrq(void)
{
    intr_flag = 0;
    FGpioSetInterruptType(&input_pin_instance, FGPIO_IRQ_TYPE_LEVEL_LOW);
    FGpioSetInterruptMask(&input_pin_instance, TRUE);

    FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_HIGH);
    fsleep_millisec(100);

    /* level low */
    FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_LOW);
}

static void FPinTriggerLevelHighIrq(void)
{
    intr_flag = 0;
    FGpioSetInterruptType(&input_pin_instance, FGPIO_IRQ_TYPE_LEVEL_HIGH);
    FGpioSetInterruptMask(&input_pin_instance, TRUE);

    FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_LOW);
    fsleep_millisec(100);

    /* level high */
    FGpioSetOutputValue(&output_pin_instance, FGPIO_PIN_HIGH);
}

/* function of gpio interrupt trigger example */
int FPinGpioIntrExample(void)
{
    int ret = 0;
    input_pin_instance.index = input_pin_index;
    output_pin_instance.index = output_pin_index;

    /* init ctrl */
    FGpioConfig input_cfg = *FGpioLookupConfig(ctrl_id);
    ret = FGpioCfgInitialize(&ctrl_instance, &input_cfg);

    FIOMuxInit();
    FIOPadSetGpioMux(input_pin_index.ctrl, (u32)input_pin_index.pin);
    FIOPadSetGpioMux(output_pin_index.ctrl, (u32)output_pin_index.pin);

    ret = FGpioPinInitialize(&ctrl_instance, &input_pin_instance, input_pin_index);
    ret = FGpioPinInitialize(&ctrl_instance, &output_pin_instance, output_pin_index);

    if (ret != 0)
    {
        printf("Fail to init ctrl or pins.");
        goto exit;
    }

    FGpioSetDirection(&input_pin_instance, FGPIO_DIR_INPUT);
    FGpioSetDirection(&output_pin_instance, FGPIO_DIR_OUTPUT);

    /* input pin irq set */
    FGpioSetInterruptMask(&input_pin_instance, FALSE); /* disable pin irq */
    if (input_pin_instance.instance->config.caps & FGPIO_CAPACITY_IRQ_TYPE)//单独中断号上报
    {
        FASSERT_MSG((FGPIO_IRQ_BY_PIN == FGpioGetPinIrqSourceType(input_pin_instance)), 
                 "Irq is not reported by pin.");
    }
    else//合成中断号上报
    {
        FASSERT_MSG((FGPIO_IRQ_BY_CONTROLLER == FGpioGetPinIrqSourceType(input_pin_instance)), 
                 "Irq is not reported by controller.");
    }

    u32 cpu_id;
    u32 irq_num;
    irq_num = ctrl_instance.config.irq_num[input_pin_index.pin];
    GetCpuId(&cpu_id);
    FPIN_TEST_INFO("cpu_id is cpu_id %d, irq_num %d", cpu_id, irq_num);
    InterruptSetTargetCpus(irq_num, cpu_id);
    InterruptSetPriority(irq_num, ctrl_instance.config.irq_priority); /* setup interrupt */
    InterruptInstall(irq_num,
                     FGpioInterruptHandler,
                     &ctrl_instance,
                     NULL); /* register intr handler */
    InterruptUmask(irq_num);

    FGpioRegisterInterruptCB(&input_pin_instance, 
                             FPinAckIrq, 
                             NULL, 
                             FALSE); /* register intr callback */

    /* trigger irq as one of four types */
    switch (irq_type)
    {
        case FGPIO_IRQ_TYPE_EDGE_FALLING:
            FPinTriggerFallingEdgeIrq();
            break;
        case FGPIO_IRQ_TYPE_EDGE_RISING:
            FPinTriggerRisingEdgeIrq();
            break;
        case FGPIO_IRQ_TYPE_LEVEL_LOW:
            FPinTriggerLevelLowIrq();
            break;
        case FGPIO_IRQ_TYPE_LEVEL_HIGH:    
            FPinTriggerLevelHighIrq();
            break;
    }

    /* wait interrupt handle done */
    fsleep_millisec(10);

    FGpioSetInterruptMask(&input_pin_instance, FALSE);

    /* deinit ctrl and pin instance */  
    FGpioDeInitialize(&ctrl_instance);

    InterruptMask(irq_num);

exit:
    /* print message on example run result */
    if (1 == intr_flag)
    {
        printf("%s@%d: pin GPIO intr example [success].\r\n", __func__, __LINE__);
        return 0;
    }
    else
    {
        printf("%s@%d: pin GPIO intr example [failure].\r\n", __func__, __LINE__);
        return 1;
    } 
}
